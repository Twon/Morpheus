#pragma once

#include <cassert>
#include <coroutine>
#include <iterator>

namespace morpheus::concurrency
{

/// \class Generator
///     Minimal generator type based on coroutines which models std::ranges::input_range. Largely inspired as a 
///     temporary solution to bridge missing support for this unil the inclusion of std::generator: 
///     https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2502r2.pdf
/// \tparam T
///     The type generated by the generator.
template<typename T>
struct Generator {

    struct promise_type;
    using handle_type = std::coroutine_handle<promise_type>;
    using value_type = T;
    using reference = std::conditional_t<std::is_reference_v<T>, T, const value_type&>;
    using pointer = std::add_pointer_t<reference>;

    Generator(handle_type h) : coro(h) {}
    ~Generator() {
        if (coro) coro.destroy();
    }
    Generator(const Generator&) = delete;
    Generator& operator = (const Generator&) = delete;
    Generator(Generator&& rhs) noexcept : coro(std::exchange(rhs.coro, {})) {}
    Generator& operator = (Generator&& rhs) noexcept {
        coro = std::exchange(rhs.coro, {});
        return *this;
    }

    struct promise_type {
        auto initial_suspend() {
            return std::suspend_always{};
        }
        auto final_suspend() noexcept {
            return std::suspend_always{};
        }
        auto get_return_object() {
            return Generator{ handle_type::from_promise(*this) };
        }
        auto return_void() {
            return std::suspend_never{};
        }

        auto yield_value(const T value) {
            current_value = value;
            return std::suspend_always{};
        }
        [[noreturn]] void unhandled_exception() {
            throw;
        }
        T current_value;
    };

    class iterator
    {
    public:
        using value_type = Generator::value_type;
        using reference = Generator::reference;
        using pointer = Generator::pointer;
        using difference_type = std::ptrdiff_t;
        using iterator_category = std::input_iterator_tag;

        iterator(iterator&& rhs) noexcept : handle(std::exchange(rhs.handle, {})) {}
        iterator& operator=(iterator&& other) noexcept
        {
            handle = std::exchange(other.handle, {});
            return *this;
        }

        iterator& operator++()
        {
            assert(!handle.done() && "Can't increment generator end iterator");
            handle.resume();
            return *this;
        }

        void operator++(int) { ++* this; }

        [[nodiscard]] reference& operator*() const noexcept
        {
            assert(!handle.done() && "Can't dereference generator end iterator");
            return handle.promise().current_value;
        }

        [[nodiscard]] pointer& operator->() const noexcept
        {
            return std::addressof(operator*());
        }

        [[nodiscard]] bool operator==(std::default_sentinel_t) const noexcept
        {
            return handle.done();
        }

    private:
        friend Generator;
        explicit iterator(std::coroutine_handle<promise_type> h) noexcept : handle(h) {}

        std::coroutine_handle<promise_type> handle;
    };

    [[nodiscard]] iterator begin() const noexcept
    {
        // Pre: Coroutine is suspended at its initial suspend point
        assert(coro && "Can't call begin on moved-from generator");
        coro.resume();
        return iterator(coro);
    }

    [[nodiscard]] std::default_sentinel_t end() const noexcept { return std::default_sentinel; }
private:
    handle_type coro;
};

}

template<typename T>
inline constexpr bool std::ranges::enable_view<morpheus::concurrency::Generator<T>> = true;