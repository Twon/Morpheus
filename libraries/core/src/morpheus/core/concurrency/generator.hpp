#pragma once

#include <morpheus/core/conformance/coro.hpp>
#include <morpheus/core/conformance/ranges.hpp>

#include <cassert>
#include <concepts>
#include <iterator>
#include <utility>

namespace morpheus::concurrency
{

/// \class Generator
///     Minimal generator type based on coroutines which models std::ranges::input_range. Largely inspired as a
///     temporary solution to bridge missing support for this unil the inclusion of std::generator:
///     https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2502r2.pdf
/// \tparam T
///     The type generated by the generator.
template <typename T>
struct Generator
{

    struct promise_type;
    using handle_type = coro_ns::coroutine_handle<promise_type>;                        ///< Handle to generator coroutines.
    using value_type = T;                                                               ///< Value type from resulting generation.
    using reference = std::conditional_t<std::is_reference_v<T>, T, const value_type&>; ///< Reference type to the value type.
    using pointer = std::add_pointer_t<reference>;                                      ///< Pointer type to the value type.

    Generator(handle_type h)
        : coro(h)
    {}

    /// Destroys the generator.
    ~Generator()
    {
        if (coro)
            coro.destroy();
    }

    Generator(const Generator&) = delete;
    Generator& operator=(const Generator&) = delete;

    Generator(Generator&& rhs) noexcept
        : coro(std::exchange(rhs.coro, {}))
    {}

    Generator& operator=(Generator&& rhs) noexcept
    {
        coro = std::exchange(rhs.coro, {});
        return *this;
    }

    struct promise_type
    {
        auto initial_suspend() { return coro_ns::suspend_always{}; }

        auto final_suspend() noexcept { return coro_ns::suspend_always{}; }

        auto get_return_object() { return Generator{handle_type::from_promise(*this)}; }

        auto return_void() { return coro_ns::suspend_never{}; }

        template <std::convertible_to<T> From>
        auto yield_value(From&& from)
        {
            current_value = std::forward<From>(from);
            return coro_ns::suspend_always{};
        }

        [[noreturn]] void unhandled_exception() { throw; }

        T current_value;
    };

    /// \class iterator
    ///     Iterator type confroming to an input iterator concept for iterating over the generated sequence.
    class iterator
    {
    public:
        using value_type = Generator::value_type; ///< Value type pointed to by the iterator.
        using reference = Generator::reference;   ///< Reference to the underlying value type pointed to by the iterator.
        using pointer = Generator::pointer;       ///< Pointer to the underlying value type pointed to by the iterator.
        using difference_type = std::ptrdiff_t;
        using iterator_category = std::input_iterator_tag;

        iterator() = default;
        iterator(iterator const& rhs) noexcept = default;
        iterator& operator=(iterator const& other) noexcept = default;

        iterator(iterator&& rhs) noexcept
            : handle(std::exchange(rhs.handle, {}))
        {}

        iterator& operator=(iterator&& other) noexcept
        {
            handle = std::exchange(other.handle, {});
            return *this;
        }

        iterator& operator++()
        {
            assert(!handle.done() && "Can't increment generator end iterator");
            handle.resume();
            return *this;
        }

        void operator++(int) { ++*this; }

        [[nodiscard]] reference& operator*() const noexcept
        {
            assert(!handle.done() && "Can't dereference generator end iterator");
            return handle.promise().current_value;
        }

        [[nodiscard]] pointer& operator->() const noexcept { return std::addressof(operator*()); }

        [[nodiscard]] bool operator==(std::default_sentinel_t) const noexcept { return handle.done(); }

    private:
        friend Generator;

        explicit iterator(coro_ns::coroutine_handle<promise_type> h) noexcept
            : handle(h)
        {}

        coro_ns::coroutine_handle<promise_type> handle;
    };

    [[nodiscard]] iterator begin() const noexcept
    {
        // Pre: Coroutine is suspended at its initial suspend point
        assert(coro && "Can't call begin on moved-from generator");
#if (__cpp_impl_coroutine >= 201902L)
        coro.resume();
#else
        const_cast<Generator*>(this)->coro.resume(); // std::experimental::resume is not marked const.
#endif
        return iterator(coro);
    }

    [[nodiscard]] std::default_sentinel_t end() const noexcept { return std::default_sentinel; }

private:
    handle_type coro;
};

} // namespace morpheus::concurrency

template <typename T>
inline constexpr bool ::morpheus::ranges::enable_view<morpheus::concurrency::Generator<T>> = true;

template <class T>
inline constexpr bool ::morpheus::ranges::enable_borrowed_range<morpheus::concurrency::Generator<T>> = true;
